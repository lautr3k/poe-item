/**
 * Modules in this bundle
 * @license
 *
 * poe-item:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: SÃ©bastien Mischler (skarab|Lautr3k)
 *   homepage: https://github.com/lautr3k/poe-item
 *   version: 0.2.0
 *
 * dot-prop:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Sindre Sorhus <sindresorhus@gmail.com>
 *   version: 5.2.0
 *
 * is-obj:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Sindre Sorhus <sindresorhus@gmail.com>
 *   version: 2.0.0
 *
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';
const isObj = require('is-obj');

const disallowedKeys = [
	'__proto__',
	'prototype',
	'constructor'
];

const isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.includes(segment));

function getPathSegments(path) {
	const pathArray = path.split('.');
	const parts = [];

	for (let i = 0; i < pathArray.length; i++) {
		let p = pathArray[i];

		while (p[p.length - 1] === '\\' && pathArray[i + 1] !== undefined) {
			p = p.slice(0, -1) + '.';
			p += pathArray[++i];
		}

		parts.push(p);
	}

	if (!isValidPath(parts)) {
		return [];
	}

	return parts;
}

module.exports = {
	get(object, path, value) {
		if (!isObj(object) || typeof path !== 'string') {
			return value === undefined ? object : value;
		}

		const pathArray = getPathSegments(path);
		if (pathArray.length === 0) {
			return;
		}

		for (let i = 0; i < pathArray.length; i++) {
			if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {
				return value;
			}

			object = object[pathArray[i]];

			if (object === undefined || object === null) {
				// `object` is either `undefined` or `null` so we want to stop the loop, and
				// if this is not the last bit of the path, and
				// if it did't return `undefined`
				// it would return `null` if `object` is `null`
				// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
				if (i !== pathArray.length - 1) {
					return value;
				}

				break;
			}
		}

		return object;
	},

	set(object, path, value) {
		if (!isObj(object) || typeof path !== 'string') {
			return object;
		}

		const root = object;
		const pathArray = getPathSegments(path);

		for (let i = 0; i < pathArray.length; i++) {
			const p = pathArray[i];

			if (!isObj(object[p])) {
				object[p] = {};
			}

			if (i === pathArray.length - 1) {
				object[p] = value;
			}

			object = object[p];
		}

		return root;
	},

	delete(object, path) {
		if (!isObj(object) || typeof path !== 'string') {
			return;
		}

		const pathArray = getPathSegments(path);

		for (let i = 0; i < pathArray.length; i++) {
			const p = pathArray[i];

			if (i === pathArray.length - 1) {
				delete object[p];
				return;
			}

			object = object[p];

			if (!isObj(object)) {
				return;
			}
		}
	},

	has(object, path) {
		if (!isObj(object) || typeof path !== 'string') {
			return false;
		}

		const pathArray = getPathSegments(path);
		if (pathArray.length === 0) {
			return false;
		}

		// eslint-disable-next-line unicorn/no-for-loop
		for (let i = 0; i < pathArray.length; i++) {
			if (isObj(object)) {
				if (!(pathArray[i] in object)) {
					return false;
				}

				object = object[pathArray[i]];
			} else {
				return false;
			}
		}

		return true;
	}
};

},{"is-obj":2}],2:[function(require,module,exports){
'use strict';

module.exports = value => {
	const type = typeof value;
	return value !== null && (type === 'object' || type === 'function');
};

},{}],"poe-item":[function(require,module,exports){
var e,t=(e=require("dot-prop"))&&"object"==typeof e&&"default"in e?e.default:e,o=function(){console.log("new ItemParser")};o.prototype.parse=function(e){return console.log("ItemParser.parse",e),{}};var r=function(){this.locales={},this.locale=null};r.prototype.getLocale=function(){return this.locale},r.prototype.setLocale=function(e){this.locale=e},r.prototype.get=function(e,o){void 0===o&&(o=null),t.get(this.locales,e,o)},r.prototype.set=function(e,o){t.set(this.locales,e,o)},r.prototype.has=function(e){return t.has(this.locales,e)},r.prototype.delete=function(e){t.delete(this.locales,e)},r.prototype.localeKey=function(e,t){return void 0===t&&(t=null),(t||this.locale)+"."+e},r.prototype.__=function(e,o){void 0===o&&(o={});var r=this.localeKey(e);return function(e,t){var o;return Object.keys(t).forEach(function(r){e=e.replace(o="{{"+r+"}}",t[r]||o)}),e}(t.get(this.locales,r,r),o)};var l=new r,n=l.__;exports.ItemParser=o,exports.i18n=l,exports.__=n;


},{"dot-prop":1}]},{},[]);
